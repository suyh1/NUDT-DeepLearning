### 任务描述

本关任务：编写一个具有类似"人脸识别"功能的网络。该网络输入为两个MNIST图片，输出为两张图片的特征距离。后续处理可以根据该特征距离是否大于或小于阈值判断这两张图片是否为同一个数字(标签0)或来自不同数字(标签1)。要求构建并训练模型，最终在测试环节，在给定的数据平衡测试集上取得AUC>0.97的结果。

本任务有600s时间限制，内存限制2G，建议大家先在自己本地机器上调试好。

### 相关知识

为了完成本关任务，你需要掌握：1. 采样数据平衡batch进行训练; 2.构建Siamese网络; 3. 定义特征距离及损失函数; 4. 评价指标；5. 梯度爆炸问题

#### 采样数据平衡batch进行训练

良好的机器学习模型应该能有效学习任务的数据分布。"人脸识别"中对于任务的要求不同，学习方式也会不同。如果我们要求同样低的认假率和拒真率。那么就需要测试集中，正例（同一数字，不同图片），反例（不同数字图片）的样本比例基本一致。并且样本涵盖不同数字的情况要尽量均匀。

因此，我们测试使用一个平衡测试集（正例和反例个数类似，正例和反例中，不同数字的采样比例也近似）。具体测试集设计中：（1）正例（同一数字对）8000个、反例（不同数字对）9000个。（2）正例中，10个数字类型各占1/10，800个。反例中，不同数字对的所有组合共C^2_10=45种，要求比例也为相同，即反例中，45种组合每个组合比例为1/45，200个。

我们讲过，训练、测试的数据分布要尽量一致。如果训练分布和测试分布差异很大，可能很难学习到期望的测试分布。如果要对平衡的测试集有良好的效果，训练的数据集，也应该是平衡且均匀的。请参考测试集的数据分布，设计相应的训练数据平衡采样方法：make_batch，使得每个batch都能尽量实现平衡均匀采样。整个训练过程中，正、负样本对都要出现的差不多。而且对于10个数字的正样本对，和各种不同类型（例：（0，1），（2，4）。。。共C^2_10=45种）的负样本，都要有充分的训练。

#### 构建Siamese网络

连体网络MINIST模型：该模型由两个相同的主干网络G(x)组成，两个主干网络共享相同的参数W。G(X）的功能定义为提取一张minist图像的特征，网络输出为两个主干网络G(x)的特征距离。如下图所示： ![ siamese_net ](https://data.educoder.net/api/attachments/1676284)

主干网络G(x)结构可以自己设计。推荐两层全连接网络：hidden1：196(14x14x1)->200; hidden2: 200->10，使用relu。按照上述的纯全连接连体网络如图。

![ siamese_basenet ](https://data.educoder.net/api/attachments/2937936)

也可以尝试其他网络结构。 注意！测试数据集数据形状为(?,14,14, 1)，为适应输入数据，不同的结构需要在输入input后做reshape处理，如上图所示。我们的测试也有600秒时间限制，网络不需太复杂。

#### 定义特征距离及损失函数

孪生网络的输出是特征距离e_w，训练目的是用给定loss调整样本对的距离e_w,使得两个同样数字组成的样本对（正样本对）特征距离近，e_w小！两个不同数字组成的样本对（负样本对）的距离远e_w大！这样，后续我们就可以用这个特征距离e_w进行分类，用来判断输入是正样本对（来自同一个数字），还是负样本对（来自不同数字）。当应用距离进行分类时，我们会采用一个距离阈值t来划分不同距离表达的比较类型。由上述距离定义，当e_w<t时，判定输入是正样本对，e_w>t时，判定为负样本对，如下图所示。

![ e_w距离 ](https://data.educoder.net/api/attachments/1676489)

t的选取可以通过网络在test数据集上的roc或pr曲线判断，一般取曲线的拐点。为实现上述距离性质，我们需要设计合理的损失函数使得：正例时，鼓励e_w小；反例时，鼓励e_w大。为此，模型采用如下的损失函数。请注意在正例(Y=0)、反例(Y=1)时，loss随e_w变化的不同趋势，理解这样设计为何能够训练正例、反例的e_w分别向不同方向变化？那么Q增大，或者减少，会对正、负样本各有怎样的惩罚力度？那么怎样根据训练效果，选取Q?可以尝试Q>5和Q<5的效果，绘制相应(e_w,loss)曲线观察。

![ loss ](https://data.educoder.net/api/attachments/1676505)

请大家根据上述提示完成代码中的损失函数

#### 评价指标

MNIST"人脸识别“Siamese网络的功能是可以根据特征距离e_w，对输入图片对的类型进行正、反类的二分类。如前所述，阈值t的变化会最终决定分类结果。而随着阈值t的变化，二分类的性能指标也发生变化。我们用以正例为中心的ROC曲线表示这种分类效果变化。并以ROC曲线下的面积：AUC作为考虑阈值t变化情况下的模型最终性能指标。本任务中，要求在测试集上的正例AUC>0.97。

评测指标以帮大家写好。在使用这些分类指标时，大家注意接口对于分类任务中类型的标签指定（接口要求正例到底用y=1还是y=0），以及对于预测结果的定义（这些指标都是面向分类任务设计，默认预测结果是对中心类型的分类概率，我们这里预测结果输出是距离e_w，如果用这些指标，需要转换为可类比为分类概率的形式。可以用归一化e_w代表分类概率，但要注意我们的类型距离方向和概率大小相反，例如正例应该是e_w小，但是分类概率应该大，因此用1-norm(e_w)表示正例分类概率，以方便使用这些指标）。正例AUC>0.97的ROC参考如下：

![ roc ](https://data.educoder.net/api/attachments/1676813)

#### 梯度爆炸问题

训练过程中，有可能出现nan的问题，一般情况是那里出现了梯度爆炸。一个情况是学习率特别大的时候迭代的连锁反应。一般可能出现在因微小变化引起梯度极大改变的地方。提示：考虑Ew距离的形式：

```
distance = K.sqrt(K.sum(tf.square(hidden_a - hidden_b), axis=1) ) 
```

他的导数，在什么情况下会特别大？如何防止？

### 编程要求

按提示补充代码完成模型的构建与训练。如果training batch的数据平衡性和均衡性和测试集类似，且训练过程中，训练精度和验证精度近似（保证泛化性能），且可以达到AUC>0.97，一般可以保证测试AUC>0.97。

对于推荐的两层全连接网络，推荐训练参数:Adam(0.01),epochs=5,batch_size=64， loss中的Q可自行设定，默认5。为防止显示过多干扰调试，训练时可设置verbose=2。

本任务有600s时间限制，内存限制2G，建议大家先在自己本地机器上调试好。

### 测试说明

测试代码会生成随机的平衡测试集，要求模型在测试集上达到正例AUC>0.97

------

开始你的任务吧，祝你成功！